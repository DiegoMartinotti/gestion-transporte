const fs = require('fs');
const path = require('path');

// Logs generated by running tsc in different modes
// By default, only include the app (raw) errors. To also include tests/e2e,
// run with INCLUDE_TESTS=1
const LOG_FILES = process.env.INCLUDE_TESTS === '1'
  ? ['tsc-errors-raw.log', 'tsc-errors-test.log', 'tsc-errors-e2e.log']
  : ['tsc-errors-raw.log'];

const FRONTEND_DIR = path.resolve(__dirname, '..');
const ESLINT_LOG = 'eslint-errors.log';

function readLines(p) {
  try {
    return fs.readFileSync(p, 'utf8').split(/\r?\n/);
  } catch {
    return [];
  }
}

// Regex example:
// src/pages/viajes/ViajeFormOriginal.tsx(59,1): error TS1128: Declaration or statement expected.
const TS_ERROR_RE = /^(.*?\.(?:ts|tsx))\((\d+),(\d+)\):\s+error\s+(TS\d+):\s+(.*)$/;

// Example eslint block:
// /abs/path/frontend/src/foo.tsx\n
//   10:5  error    Some message                  rule/id
//   12:3  warning  Another message               rule/id
function parseEslintLog(lines) {
  const results = [];
  let currentFile = null;
  for (const raw of lines) {
    const line = raw.trimEnd();
    if (!line) continue;

    // Detect file header (absolute or relative path)
    if (/^(\/|\.\/|src\/)/.test(line) && line.includes('.ts')) {
      // Normalize to frontend-relative path
      let p = line;
      const idx = p.indexOf('/frontend/');
      if (idx !== -1) p = p.slice(idx + '/frontend/'.length);
      // Ensure starts at src/ or tests/ or e2e/
      const relIdx = p.indexOf('src/');
      const testsIdx = p.indexOf('tests/');
      const e2eIdx = p.indexOf('e2e/');
      if (relIdx !== -1) p = p.slice(relIdx);
      else if (testsIdx !== -1) p = p.slice(testsIdx);
      else if (e2eIdx !== -1) p = p.slice(e2eIdx);
      currentFile = p;
      continue;
    }

    // Match issue line under current file
    // e.g., "  12:17  error  Message  rule/id"
    const m = line.match(/^\s*(\d+):(\d+)\s+(error|warning)\s+(.*?)\s+([@a-zA-Z0-9_\-/\.]+)$/);
    if (m && currentFile) {
      const [, ln, col, sev, msg, rule] = m;
      results.push({ file: currentFile, line: Number(ln), col: Number(col), severity: sev, rule, msg });
    }
  }
  return results;
}

function capitalize(s) { return s ? s.charAt(0).toUpperCase() + s.slice(1) : s; }

function deriveFromFileNameForHooks(fileName) {
  const m = fileName.match(/^use([A-Z][A-Za-z]+)/);
  if (m) return m[1];
  return 'Otros';
}

function deriveFromFileNameForServices(fileName) {
  const m = fileName.match(/^(.*?)(Service|Api)\.[tj]s/);
  if (m) return capitalize(m[1]);
  if (/^api\.[tj]s$/.test(fileName)) return 'API';
  return 'Otros';
}

function mapComponentFolderToName(folder) {
  const map = {
    base: 'UI Base',
    maps: 'Mapas',
    reports: 'Reportes',
    tables: 'Tablas',
    preview: 'Previsualización',
    tarifa: 'Tarifa',
    cards: 'Tarjetas',
    selectors: 'Selectores',
    indicators: 'Indicadores',
    layout: 'Layout',
    modals: 'Modales',
    calculation: 'Cálculo',
    forms: 'Formularios'
  };
  return map[folder] || capitalize(folder || 'Otros');
}

function groupForPath(filePath) {
  const p = filePath.replace(/\\/g, '/');
  if (p.startsWith('src/components/')) {
    const parts = p.split('/');
    const feature = mapComponentFolderToName(parts[2]);
    return `Componentes/${feature}`;
  }
  if (p.startsWith('src/pages/')) {
    const parts = p.split('/');
    const area = parts[2] ? capitalize(parts[2]) : 'Otros';
    return `Páginas/${area}`;
  }
  if (p.startsWith('src/hooks/')) {
    const fileName = p.split('/').pop();
    const domain = deriveFromFileNameForHooks(fileName);
    return `Hooks/${domain}`;
  }
  if (p.startsWith('src/services/')) {
    const fileName = p.split('/').pop();
    const svc = deriveFromFileNameForServices(fileName);
    return `Servicios/${svc}`;
  }
  if (p.startsWith('src/templates/excel/')) {
    const fileName = p.split('/').pop();
    const m = fileName.match(/^([A-Za-z]+)/);
    const domain = m ? m[1] : 'Otros';
    return `Plantillas Excel/${capitalize(domain)}`;
  }
  if (p.startsWith('src/utils/')) {
    const parts = p.split('/');
    const sub = parts[2] ? capitalize(parts[2]) : 'Otros';
    return `Utils/${sub}`;
  }
  if (p.startsWith('src/constants/')) return 'Constantes';
  if (p.startsWith('src/types/')) return 'Tipos';
  if (p.startsWith('src/contexts/')) return 'Contextos';
  if (p.startsWith('src/context/')) return 'Contextos';
  if (p.startsWith('tests/')) return 'Tests unitarios';
  if (p.startsWith('e2e/')) return 'Tests E2E';
  if (p.startsWith('src/')) return 'Core/Otros';
  return 'Otros';
}

function main() {
  const errorsByGroup = new Map(); // TS
  const eslintByGroup = new Map(); // ESLint
  const seen = new Set();
  let totalTS = 0;
  let totalESLint = 0;
  const filesWithTSErrors = new Set();
  const filesWithESLint = new Set();

  const excludeTestsAndE2E = process.env.INCLUDE_TESTS !== '1';
  for (const lf of LOG_FILES) {
    const fullPath = path.join(FRONTEND_DIR, lf);
    const lines = readLines(fullPath);
    for (const line of lines) {
      const m = line.match(TS_ERROR_RE);
      if (!m) continue;
      const [, file, lineNo, colNo, code, msg] = m;
      // Skip tests and e2e paths when aggregating app-only errors
      if (excludeTestsAndE2E && (file.startsWith('tests/') || file.startsWith('e2e/'))) {
        continue;
      }
      const key = `${file}:${lineNo}:${colNo}:${code}:${msg}`;
      if (seen.has(key)) continue;
      seen.add(key);
      totalTS += 1;
      filesWithTSErrors.add(file);
      const group = groupForPath(file);
      if (!errorsByGroup.has(group)) errorsByGroup.set(group, []);
      errorsByGroup.get(group).push({ file, line: Number(lineNo), col: Number(colNo), code, msg });
    }
  }

  // ESLint aggregation (optional; only if log exists)
  const eslintLogPath = path.join(FRONTEND_DIR, ESLINT_LOG);
  const eslintLines = readLines(eslintLogPath);
  if (eslintLines.length > 0) {
    const issues = parseEslintLog(eslintLines);
    for (const i of issues) {
      if (excludeTestsAndE2E && (i.file.startsWith('tests/') || i.file.startsWith('e2e/'))) continue;
      totalESLint += 1;
      filesWithESLint.add(i.file);
      const group = groupForPath(i.file);
      if (!eslintByGroup.has(group)) eslintByGroup.set(group, []);
      eslintByGroup.get(group).push(i);
    }
    // sort ESLint entries per group
    for (const [g, list] of eslintByGroup.entries()) {
      list.sort((a, b) => a.file.localeCompare(b.file) || a.line - b.line || a.col - b.col);
    }
  }

  // Sort groups and entries within each group
  const groupNames = Array.from(errorsByGroup.keys()).sort((a, b) => a.localeCompare(b));
  for (const g of groupNames) {
    errorsByGroup.get(g).sort((a, b) => a.file.localeCompare(b.file) || a.line - b.line || a.col - b.col);
  }

  const out = [];
  out.push('# Errores de TypeScript y ESLint agrupados por funcionalidad');
  out.push('');
  out.push(`Generado: ${new Date().toISOString()}`);
  out.push('');
  out.push(`Total de errores TS: ${totalTS}`);
  out.push(`Total de issues ESLint: ${totalESLint}`);
  out.push(`Archivos con errores TS: ${filesWithTSErrors.size}`);
  out.push(`Archivos con issues ESLint: ${filesWithESLint.size}`);
  out.push('');

  if (groupNames.length === 0 && eslintByGroup.size === 0) {
    out.push('No se encontraron errores en los logs analizados.');
  } else {
    const allGroupNames = Array.from(new Set([...groupNames, ...Array.from(eslintByGroup.keys())])).sort((a,b)=>a.localeCompare(b));
    for (const g of allGroupNames) {
      const tsList = errorsByGroup.get(g) || [];
      const esList = eslintByGroup.get(g) || [];
      out.push(`## ${g}`);
      if (tsList.length) {
        out.push(`- TypeScript (${tsList.length})`);
        for (const e of tsList) {
          out.push(`  - \`${e.file}:${e.line}:${e.col}\` - \`${e.code}\`: ${e.msg}`);
        }
      }
      if (esList.length) {
        out.push(`- ESLint (${esList.length})`);
        for (const i of esList) {
          out.push(`  - \`${i.file}:${i.line}:${i.col}\` - ${i.severity.toUpperCase()} \`${i.rule}\`: ${i.msg}`);
        }
      }
      out.push('');
    }
  }

  const outPath = path.join(FRONTEND_DIR, 'tsc-errors-agrupados.md');
  fs.writeFileSync(outPath, out.join('\n'), 'utf8');
  console.log(`Escrito: ${outPath}`);
}

main();
